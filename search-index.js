var searchIndex = {};
searchIndex["carboxyl"] = {"doc":"*Carboxyl* provides primitives for functional reactive programming in Rust.\nIt draws inspiration from the [Sodium][sodium] libraries and Push-Pull FRP,\nas described by [Elliott (2009)][elliott_push_pull].","items":[[3,"Sink","carboxyl","An event sink.",null,null],[3,"Stream","","A stream of events.",null,null],[3,"Signal","","A continuous signal that changes over time.",null,null],[11,"clone","","",0,null],[11,"new","","Create a new sink.",0,{"inputs":[],"output":{"name":"sink"}}],[11,"stream","","Generate a stream that fires all events sent into the sink.",0,null],[11,"send_async","","Asynchronous send.",0,null],[11,"feed","","Feed values from an iterator into the sink.",0,null],[11,"feed_async","","Asynchronous feed.",0,null],[11,"send","","Send a value into the sink.",0,null],[11,"clone","","",1,null],[11,"never","","Create a stream that never fires. This can be useful in certain\nsituations, where a stream is logically required, but no events are\nexpected.",1,{"inputs":[],"output":{"name":"stream"}}],[11,"map","","Map the stream to another stream using a function.",1,null],[11,"filter","","Filter a stream according to a predicate.",1,null],[11,"filter_map","","Both filter and map a stream.",1,null],[11,"merge","","Merge with another stream.",1,null],[11,"coalesce","","Coalesce multiple event firings within the same transaction into a\nsingle event.",1,null],[11,"hold","","Hold an event in a signal.",1,null],[11,"events","","A blocking iterator over the stream.",1,null],[11,"fold","","Scan a stream and accumulate its event firings in a signal.",1,null],[11,"filter_some","","Filter a stream of options.",1,null],[11,"switch","","Switch between streams.",1,null],[11,"clone","","",2,null],[11,"new","","Create a constant signal.",2,{"inputs":[{"name":"a"}],"output":{"name":"signal"}}],[11,"sample","","Sample the current value of the signal.",2,null],[11,"cyclic","","Create a signal with a cyclic definition.",2,{"inputs":[{"name":"f"}],"output":{"name":"signal"}}],[11,"snapshot","","Combine the signal with a stream in a snapshot.",2,null],[11,"map","","Map a signal using a function.",2,null],[11,"switch","","Switch between signals.",2,null],[11,"fmt","","",2,null],[0,"lift","","Lifting of n-ary functions.",null,null],[5,"lift0","carboxyl::lift","Lift a 0-ary function.",null,{"inputs":[{"name":"f"}],"output":{"name":"signal"}}],[5,"lift1","","Lift a unary function.",null,{"inputs":[{"name":"f"},{"name":"signal"}],"output":{"name":"signal"}}],[5,"lift2","","Lift a binary function.",null,{"inputs":[{"name":"f"},{"name":"signal"},{"name":"signal"}],"output":{"name":"signal"}}],[5,"lift3","","Lift a ternary function.",null,{"inputs":[{"name":"f"},{"name":"signal"},{"name":"signal"},{"name":"signal"}],"output":{"name":"signal"}}],[5,"lift4","","Lift a quarternary function.",null,{"inputs":[{"name":"f"},{"name":"signal"},{"name":"signal"},{"name":"signal"},{"name":"signal"}],"output":{"name":"signal"}}],[14,"lift","carboxyl","",null,null]],"paths":[[3,"Sink"],[3,"Stream"],[3,"Signal"]]};
searchIndex["lazy_static"] = {"doc":"A macro for declaring lazily evaluated statics.","items":[[14,"lazy_static","lazy_static","",null,null]],"paths":[]};
initSearch(searchIndex);
